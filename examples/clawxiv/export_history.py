#!/usr/bin/env python3
"""Export SWARM history.json to a ClawXiv-compatible API endpoint.

This script is intentionally minimal and uses only the Python standard library.
"""

from __future__ import annotations

import argparse
import json
import os
import sys
import urllib.error
import urllib.parse
import urllib.request


def _is_safe_clawxiv_url(url: str) -> bool:
    parsed = urllib.parse.urlparse(url)
    if parsed.scheme != "https":
        return False
    if parsed.netloc != "www.clawxiv.org":
        return False
    return parsed.path.startswith("/api/v1/")


class _NoRedirect(urllib.request.HTTPRedirectHandler):
    def redirect_request(self, req, fp, code, msg, headers, newurl):
        raise urllib.error.HTTPError(
            req.full_url,
            code,
            "Redirects are not allowed for ClawXiv requests.",
            headers,
            fp,
        )


def _build_payload(history: dict) -> dict:
    return {
        "source": "swarm",
        "simulation_id": history.get("simulation_id"),
        "started_at": history.get("started_at"),
        "ended_at": history.get("ended_at"),
        "n_epochs": history.get("n_epochs"),
        "steps_per_epoch": history.get("steps_per_epoch"),
        "n_agents": history.get("n_agents"),
        "seed": history.get("seed"),
        "epochs": history.get("epoch_snapshots", []),
    }


def _post_json(url: str, payload: dict, api_key: str | None, timeout: int) -> int:
    if not _is_safe_clawxiv_url(url):
        sys.stderr.write(
            "Refusing to send request. Only https://www.clawxiv.org/api/v1/* is allowed.\n"
        )
        return 2

    body = json.dumps(payload).encode("utf-8")
    headers = {
        "Content-Type": "application/json",
        "User-Agent": "swarm-clawxiv-export/0.1",
    }
    if api_key:
        headers["X-API-Key"] = api_key

    req = urllib.request.Request(url, data=body, headers=headers, method="POST")
    try:
        opener = urllib.request.build_opener(_NoRedirect())
        with opener.open(req, timeout=timeout) as resp:
            sys.stdout.write(resp.read().decode("utf-8", errors="replace"))
            sys.stdout.write("\n")
            return resp.status
    except urllib.error.HTTPError as exc:
        sys.stderr.write(exc.read().decode("utf-8", errors="replace"))
        sys.stderr.write("\n")
        return exc.code


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Export SWARM history.json to ClawXiv."
    )
    parser.add_argument(
        "--history",
        required=True,
        help="Path to history.json generated by a SWARM run.",
    )
    parser.add_argument(
        "--api-url",
        default=os.getenv("CLAWXIV_API_URL"),
        help="ClawXiv endpoint URL (or set CLAWXIV_API_URL).",
    )
    parser.add_argument(
        "--api-key",
        default=os.getenv("CLAWXIV_API_KEY"),
        help="ClawXiv API token (or set CLAWXIV_API_KEY).",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print payload instead of sending a request.",
    )
    parser.add_argument(
        "--timeout",
        type=int,
        default=15,
        help="HTTP timeout in seconds.",
    )
    args = parser.parse_args()

    with open(args.history, "r", encoding="utf-8") as f:
        history = json.load(f)

    payload = _build_payload(history)

    if args.dry_run:
        print(json.dumps(payload, indent=2, sort_keys=True))
        return 0

    if not args.api_url:
        sys.stderr.write("Missing --api-url or CLAWXIV_API_URL.\n")
        return 2

    status = _post_json(args.api_url, payload, args.api_key, args.timeout)
    if status >= 400:
        sys.stderr.write(f"Request failed with status {status}.\n")
        return 1

    sys.stdout.write(f"Posted metrics to {args.api_url} (status {status}).\n")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
